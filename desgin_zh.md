# Polkaeos: 一种无信任损失的polkadot-EOSIO跨链桥实现

范杨 fanyang.coder@gmail.com

## 0. 前言

在Polkadot中跨链通信是其最关键的部分，Polkadot白皮书中提出了与以太坊和比特币的跨链通信设计，本篇文档提出了Polkaeos，这是一种无信任损失的polkadot-EOSIO跨链桥实现方案，目前，EOSIO是主要的区块链底层技术之一，所以Polkadot与基于EOSIO技术的链建立跨链桥具备很大的价值。

为了实现高性能且低延迟的运行DAPP，EOSIO做了很多设计上的取舍，一方面这使得EOSIO可以迅速落地，但另一方面也带来很大的中心化程度的困扰，同时EOSIO的特性也使得与其跨链十分困难：EOSIO的节点部署消耗高昂，其链上计算量相对于其他公链也十分庞大，这往往意味着如果按照常规的方式很难在无信任损失的情况下实现与EOSIO的链的互操作性。

Polkaeos基于polkadot与EOSIO的特性和功能实现了一种无信任损失跨链桥，以下是设计的具体方案。

## 1. 设计目标

作为承载两个相互独立的区块链系统之前互操作的桥接链，Polkaeos应该尽可能的去中心化，其可信任的假设不应在两个区块链的可信任假设之上添加新的假设。

同时，在Polkaeos中，担任各种角色的节点不应有过高的门槛，包括抵押Token的价值下限、节点的稳定性、性能、网络带宽需求等，这可以避免Polkaeos节点真实结构趋于中心化。这里合适的门槛应该是可以允许Polkaeos与EOSIO的参与者，即同时拥有一定的Polkaeos token与EOSIO核心Token，并且拥有具备部署合约能力的EOSIO账户，对节点的要求应是具有网络链接的达到近两年平均性能的计算机，其带宽要求应该是可以满足同时接受和发送Polkaeos与EOSIO实时区块信息的能力。

由于Polkaeos与EOSIO都是具备图灵完备合约支持的公有链，所以以上的要求应该是在不添加见证人节点的情况下，任意Polakeos与EOSIO间中继节点的最低要求。

在Polkadot的视角下，Polkaeos将会被设计成一个尽可能独立的Runtime模块，而非一个单一的平行链，这将允许polkadot中有与需求的平行链可以快速的具备与EOSIO链互操作的能力，为此Polkaeos的跨链实现应该是共识无关的，且不应占据过量的链上计算与存储资源。

## 2. 从EOSIO到polkadot

Polkaeos首先需要解决的是映射EOSIO状态到Polkaeos的问题。

在polkadot白皮书中给出了从ETH到polkadot的状态映射方案，但是对于从EOSIO到polkadot这个方案需要针对EOSIO特征进行一定的改进和特化。

第一，在Polkaeos中从EOSIO到polkadot的状态映射需要被严格的保证是可信的，因此基于少数验证者和钓鱼者的解决方案不是非常有效，同时也要注意到EOSIO的区块数量相对其他区块链十分多，这意味着一旦少数验证者作恶，即使钓鱼者发现进而链作出惩罚，但是之后的状态恢复与EOSIO重新保持同步也将是很困难的。

第二，EOSIO不同于使用PoW共识机制的链，其区块是有最终确定性的，也就是EOSIO中的不可逆区块，对于Polkaeos来说，要保证区块的可信，其节点就只能同步不可逆的区块，而判定不可逆需要基于EOSIO的共识机制验证区块，也就是说，所有参与验证的节点都需要完成EOSIO的共识。如果没有针对性的技术，这将抬高节点的参与门槛。

第三，EOSIO提供了丰富的合约功能，Polkaeos可以基于EOSIO的合约更加简单的实现中继过程中的某些断言。

以上意味着Polkaeos需要作出很多工作以更好的支持从EOSIO到polkadot的状态映射。

### 2.3 EOSIO轻节点

Polkaeos的一个重要工作之一就是实现EOSIO轻节点，这里为了保证链的可信，EOSIO轻节点需要足够的“轻”。

在EOSIO网络中，一个全节点对于机器性能、网络和运维的要求是非常高的，这也意味着，即使要求少数验证者和钓鱼者启动全节点也是一件不现实的事，这会使得整个桥从经济成本上就不成立，所以Polkaeos需要一个可用的EOSIO轻节点，在EOSIO白皮书中描述了轻节点在设计上是可行的，但目前并没有这方面可用的实现，所以Polkaeos需要自行实现一个EOSIO轻节点。

EOSIO对节点高需求的一个主要原因即使其内存（RAM）状态，这些状态十分庞大且没有在区块中验证，所以任何一个想要获取任意状态的节点都需要完整的重放一遍EOSIO的区块，虽然可以通过快照功能复原节点，但即使对于保持同步的节点，一旦出现故障其复原时间也比较漫长。同时由于EOSIO链上的事务比较繁忙，峰值时可达4000 TPS左右，同步实时的EOSIO区块也会对机器的要求较高。

综合以上考虑，Polkaeos实现的EOSIO轻节点不会处理每一个事务，而仅仅验证区块头的有效性，同时确认其区块不可逆。

不处理每一个事务意味轻节点的大部分工作可以并行完成，而且也可以从任意区块高度开始同步，在目前的Polkaeos原型实现中，轻节点只需占用很少的计算资源即可完成验证。

不处理每一个事务虽然允许轻节点占用很少的资源，但是也使得轻节点无法提供EOSIO的内存（RAM）状态，而在EOSIO中几乎所有的状态都在内存中，一些操作（EOSIO称之为Action）也需要通过执行事务来触发，这就需要一些断言机制来保证Polkaeos仅仅基于区块数据就可以可信的获得EOSIO的状态，在Polkaeos中，通过EOSIO状态断言合约和状态静态断言合约来实现。

### 2.4 EOSIO状态断言合约

Polkaeos映射全部EOSIO的状态，所以只需确定某一状态在某一区块高度的值，或者可以根据某区块高度区间内的事务来确定某一状态在区间内的值即可。

为此Polkaeos提出了状态断言合约和状态静态断言合约，通过这两个合约来达到以上目的。

状态断言合约十分简单，合约仅仅是判断事务行为（Action）提交的值和当前内存值是否一致，只要该行为执行成功且包含这个行为的区块达到不可逆状态，就可以认定断言有效。

状态断言合约可以适应任意的任意的EOSIO状态结构，为了确保可信，这个合约账户应为黑洞账户，且其部署的合约Hash应被确认，保证没有改变，这样除非EOSIO链中超过2/3的超级节点一致篡改这个合约本身或其运行结果，否则可以认为这个合约是可信的。

即便EOSIO链中超过2/3的超级节点一致篡改该合约，Polkaeos也可以发现合约hash变化或者发现分叉出现，以此可以关闭中继过程以保证Polkaeos的安全。

### 2.5 EOSIO状态静态断言合约

除了确定某一状态在某一区块高度的值之外，Polkaeos也需要根据某区块高度区间内的事务来确定某一状态在区间内的值。

对于任意一个状态，我们只要知道其初始状态的值和全部状态变换，即可得出当前状态，对于EOSIO上的状态，可以通过合约来使得该状态不能被区块中事务以外的行为所改变（主要是inline action），那么这个状态我们可以定义为“静态状态”，这也就意味着如果一个状态可以被确认为静态状态，那么根据某区块高度区间内的事务来确定该状态在区间内的值。

在EOSIO v1.8的几个特性被激活以后，确保一个状态是静态变得很简单，只要这个状态限制其变化的行为且不接受inline action的方式（这其中也包括即将废除的事件调用触发的action -- 两者底层的实现其实是一致的）调用这些行为即可。

无法使用inline action可能会限制一些合约的功能，这可以比较简单的绕过，即采用二次确认的机制，通过存储两个关联的状态，通过一个同步的action进行确认性的同步即可实现。

状态断言合约和状态静态断言合约所消耗的资源很少，除了其本身的RAM消耗，不会增加额外的RAM消耗，另外这两个合约几乎不进行计算，所以CPU消耗也极少，NET消耗和要确认状态的大小相关，对于比较大的状态，如一些在RAM中的重要文件，可以采用断言其Hash的方式完成。

状态断言合约和状态静态断言合约可以使得Polkaeos可以只基于区块数据完成从EOSIO到polkadot的状态映射，并且带来的资源消耗很少，事实上，在EOSIO中这可以被认为是零资源消耗的。以上两个合约实际上将EOSIO中的状态分为两类：一类是“静态确认”的，另一类是“计算确认”的，静态确认的状态不仅仅可以通过Polkaeos映射到polkadot生态中，也可以被很多其他应用和跨链场景使用。

### 2.6 EOSIO区块裁剪

通过以上的机制可以很好的实现从EOSIO到polkadot的状态映射，同时对参与者的要求很低，但是依然需要参与的节点同步完整的EOSIO实时数据，这一数据量比较大，虽然如果要保证跨链过程的可信程度，那么就必须验证所有的EOSIO区块头数据，但是某些特定情况下，我们可以作出一些特化以优化。

EOSIO侧可以使用特定的实现来对区块进行裁剪和筛选，比如在区块中定义一些“关键”区块，所有涉及到跨链或者静态状态的事务可以只打包到这些关键区块中，同时关键区块中可以选择的嵌入其上个关键区块的验证信息，这相当于在EOSIO中筛选出一条链中的链，以上过程可以完全基于合约实现，但是需要链给出一定的合约API支持以确认关键区块，目前EOSIO在v1.8之后正在着手添加这些功能。

经过筛选之后，Polkaeos中的节点只需要同步EOSIO区块头和关键区块的区块内容，这将大大减少需要同步的数据数量。

对于一些基于EOSIO技术的链，也可以通过链本身的修改来达到这一效果，相对与通过合约实现，基于链本身的改动将会更具效果。

## 3. 从polkadot到EOSIO

EOSIO基于DPOS机制，所以很难通过上述同样的机制完成从polkadot到EOSIO的状态映射，有了从EOSIO到到polkadot的可信状态映射之后，Polkaeos可以检查从polkadot到EOSIO的状态映射是否可信，这样从polkadot到EOSIO的状态映射可以由任何个体完成。

### 3.1 Polkaeos状态映射证明

我们可以将从polkadot到EOSIO的状态映射视为两个关联的状态变换：

比如在polkadot中的$p$状态对应EOSIO中的$p'$状态，那么映射过程中就可看作以下两个变换$\vec p$ 与 $\vec p'$ ：

$$p = s \implies p' = s$$

再如常见的Token映射过程，从polkadot到EOSIO“出金”的过程可以记为如下两个变换：

$$a\overset{n,a^T}{\to}N \implies N'\overset{n}{\to}a^T$$

显然这两个变换是一一对应的，实际上当需要映射状态到EOSIO时只需要从polkadot的状态变换得出EOSIO状态变换，并计算其Hash，将Hash推送到EOSIO即可，之后当EOSIO侧执行变换时通过状态静态断言合约就可以将结果反馈给polkadot侧，这个过程就称为Polkaeos状态映射证明。

Polkaeos状态映射证明将会包含流水id信息与区块高度，并且添加校验码，虽然一定程度上增加了消息的大小，但是会显著防止在进行操作时由于同步问题产生的误操作。

### 3.2 中继“矿工”

Polkaeos状态映射证明的过程可以由任意参与Polkaeos的节点来完成，所需要的就是一小部分押金，这些节点或者个体被称之为中继“矿工”，每次矿工完成证明，其都会获得手续费收益，每个等待传递的证明可以设置一个额外的手续费以更快的完成。

由于映射的过程只涉及到Hash值，所以每一次映射的消耗实际是固定的，这也就意味着矿工的成本是固定的，所以Polkaeos中可以拥有大量的矿工，这样对于矿工来说，系统并不要求其保证稳定性，同时在设计传递信息的合约时，考虑到了因为网络、同步及计算量相关的误操作可能，防止矿工因为意外错误而被惩罚。只有当矿工恶意传递完全不存在的映射时才会遭到惩罚。

矿工需要在Polkaeos缴纳押金，每次状态映射证明确认完成前，矿工不能进行其他状态映射证明，这一间隔时间实际上是固定的，通过两侧的合约即可完成。需要注意到的是，如果矿工多缴纳押金实际也可以被允许一次完成多笔状态映射证明，但是这其实等价于某些个体多注册几个矿工，所以可以不用特别设计。

为了保证矿工可信，同时为了保证矿工押金下限不至于过高以限制用户的参与，所以每个状态映射所涉及的token价值应该有上限，多数的状态映射都会具有一定的价值，可以定义为矿工作恶所能获得的最大价值，显然矿工的押金需要大于这个价值，所以为了保证矿工押金下限不至于过高以限制用户的参与，中继合约可以限制这个最大价值，这里比较典型的就是“出金”的过程，简单的设置一个单笔的上限就可以达到此目的。

矿工因为涉及到两条链的行为，所以需要在两条链上都确认其状态，其注册过程如下：

- 首先，一个矿工应该先在EOSIO上临时抵押Token以完成EOSIO侧的注册。
- 其后当状态映射至Polkaeos后，在Polkaeos抵押其矿工押金，进而获得映射权限。
- 此时其第一个状态映射证明就是证明自身矿工押金的状态映射，这个状态映射证明在EOSIO侧将会为其押金设置一个解锁区块高度。
- （可选）在这个区块高度之前其他矿工可以作为钓鱼人检查矿工是否伪造了押金状态，如果是，则可以通过另外一次状态映射证明来得到新矿工在EOSIO侧的押金。
- （可选）如果矿工并没有在Polkaeos抵押其矿工押金就开始进行其他证明，则被视为伪造状态，其他矿工可以作为钓鱼人获取在EOSIO侧的押金。
- 如果没有矿工证明其伪造押金状态，则可视为矿工已经完成其状态确认，此时矿工可以在锁定高度之后领会在EOSIO侧的临时押金。

以上这一略显复杂的过程是为了保证矿工的注册过程不会受到其他矿工干扰，特别的，Polkaeos的第一个矿工可以通过自身完成最初的状态映射，当然由于此时不存在其他矿工，所以矿工在EOSIO的临时押金的冻结期将会长一些。

由于从EOSIO到polkadot的映射是可信的，所以矿工的注册过程应在EOSIO侧开始，进而每一步行为都受到两侧的链的机制的保护。

上面的设计保证了矿工是完全去中心化和市场化的行为，矿工无法被垄断也没有门槛，当随着Polkaeos的发展而中继通道产生拥塞的时候，必然会有新的矿工加入以获得手续费，当Polkaeos的中继通道闲置时，矿工也可以根据自身情况自行退出。

### 3.3 特例

对于一些基于EOSIO的链，如果可以进行一些更新，则可以基于类似从EOSIO到polkadot的映射的方式来完成从polkadot到EOSIO的映射，进一步的，可以将EOSIO链上的超级节点的治理机制纳入Polkaeos中。

## 4. 应用

通过无信任损失的与EOSIO链之间的跨链桥可以实现大量应用，EOSIO为了承载高性能低延迟的DAPP而作出很多的妥协，这使得EOSIO在一定程度上表现了中心化的趋势，通过Polkaeos，polkadot生态可以在一定的场景下即保证去中心化又能承载高性能低延迟的DAPP应用。

另一方面，基于EOSIO的链可以通过Polkaeos将其状态映射至基于polkadot的平行链，以此加强其去中心化程度。

以下是几个可能的基于Polkaeos应用：

### 4.1 Polkadot与EOSIO链之间的价值转移通道

最典型的应用就是Polkadot与EOSIO链之间的价值转移通道，也就是转移双向的通证到对端，这可以支持一些基于通证的应用，如去中心化交易所、Defi应用等。

### 4.2 跨链合约

基于Polkaeos可以实现跨链智能合约，Polkadot与EOSIO都支持复杂的智能合约，通过跨链的机制，可以实现一个DAPP同时在两条甚至多条异构链上运行。

对于同构的平行链，这样的跨链合约意义不大，但对于异构的链，尤其是在EOSIO中，实现跨链合约可以使得合约或者DAPP可以基于其需求选择在这两条链上运行合适的合约，
比如某些重要的结算（如生成密码学安全的随机数）可以在Polkadot的平行链完成，一些高计算量的逻辑可以在EOSIO中运行。

### 4.3 Polkadot平行链的计算子链

基于Polkaeos可以为Polkadot的平行链添加基于EOSIO实现的计算子链，这类似与通常的Layer 2架构。

作为计算子链的EOSIO链可以被深入的修改和定制，以将自身纳入进平行链的治理机制中，这样Polkaeos的方案可以被简化，使得跨链过程可以更加快速的完成。

EOSIO的架构和设计与Substrate有很大区别，

### 4.4 EOSIO状态证明

基于EOSIO的链也可以基于Polkaeos来得到进一步的改进，基于EOSIO中的链往往趋于强烈的中心化，这些链的状态在某些情况可以被篡改，基于Polkaeos，EOSIO的用户可以映射其状态到Polkadot平行链作为存证，以防止在某些情况下的异常。

## 5. 总结

Polkadot与EOSIO都是目前重要的区块链底层技术，二者的互操作性可以为对方都带来更多的功能性，以此支撑更加复杂的去中心化应用。
除了实现polkadot-EOSIO跨链桥，Polkaeos的方案也可以被参考用来实现高性能链之间的跨链机制，基于类似的技术，也可以建立polkadot到波场等公链的跨链桥。
